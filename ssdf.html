<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Minecraft Demo</title>
  <style>
    /* 기본 스타일 설정 */
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    /* 시작 전 안내 화면 (포인터 잠금) */
    #blocker {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #instructions {
      font-size: 36px;
      color: #ffffff;
      text-align: center;
      cursor: pointer;
    }
    /* 간단한 인벤토리 UI (하단 중앙) */
    #inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      color: #fff;
      font-size: 20px;
      z-index: 101;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <!-- 시작 안내 및 포인터 잠금 블록 -->
  <div id="blocker">
    <div id="instructions">클릭하여 게임 시작</div>
  </div>
  <!-- 인벤토리 UI -->
  <div id="inventory">블럭 인벤토리: <span id="blockCount">0</span></div>

  <!-- Three.js 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- PointerLockControls -->
  <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
  <script>
    let camera, scene, renderer, controls;
    let objects = []; // 씬에 추가된 블럭들
    let raycaster;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();

    // 인벤토리 변수
    let blockInventory = 0;
    const blockCountElement = document.getElementById('blockCount');

    // 기본 설정
    const blockSize = 10;  // 블럭 한 변의 길이

    // 씬 생성
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // 하늘색
    scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

    // 카메라 생성 (1인칭 시점)
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.y = 10;

    // 렌더러 생성
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 조명 추가
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(0, 200, 100);
    scene.add(dirLight);

    // 간단한 평면(땅) 생성 – 여러 블럭으로 이루어진 그리드
    const groundWidth = 20; // x,z 방향으로 몇 개의 블럭이 배치될지 결정 (총 groundWidth x groundWidth)
    for (let i = -groundWidth/2; i < groundWidth/2; i++) {
      for (let j = -groundWidth/2; j < groundWidth/2; j++) {
        const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        // 땅 블럭은 초록색 계열
        const material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.x = i * blockSize;
        cube.position.y = -blockSize/2; // 바닥 위에 딱 맞게 배치
        cube.position.z = j * blockSize;
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);
        objects.push(cube);
      }
    }

    // PointerLockControls 설정 (1인칭 시점)
    controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    // 포인터 잠금 관련 DOM 처리
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', function(){
      controls.lock();
    }, false);
    controls.addEventListener('lock', function(){
      blocker.style.display = 'none';
    });
    controls.addEventListener('unlock', function(){
      blocker.style.display = 'flex';
    });

    // 키보드 이벤트 (이동, 점프)
    const onKeyDown = function(event) {
      switch(event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump === true) velocity.y += 350;
          canJump = false;
          break;
      }
    };
    const onKeyUp = function(event) {
      switch(event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    };
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);

    // Raycaster 생성 (블럭 상호작용용)
    raycaster = new THREE.Raycaster();

    // 마우스 이벤트: 좌클릭(블럭 파괴), 우클릭(블럭 배치)
    document.addEventListener('mousedown', onMouseDown, false);
    function onMouseDown(event) {
      if (!controls.isLocked) return;
      // event.button: 0은 좌클릭, 2는 우클릭
      if (event.button === 0) {
        destroyBlock();
      } else if (event.button === 2) {
        placeBlock();
      }
    }
    // 우클릭 시 기본 메뉴가 뜨지 않도록 함
    document.addEventListener('contextmenu', function(event){
      event.preventDefault();
    }, false);

    // 블럭 파괴: 카메라 중앙에서 레이캐스트로 블럭 탐색 후 파괴
    function destroyBlock() {
      // 화면 중앙 좌표 (0,0)로 레이캐스터 설정
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(objects);
      if (intersects.length > 0) {
        const intersect = intersects[0];
        // 일정 거리 이내에서만 파괴 가능 (약 50 단위)
        if (intersect.distance < 50) {
          const obj = intersect.object;
          scene.remove(obj);
          const index = objects.indexOf(obj);
          if (index > -1) objects.splice(index, 1);
          // 파괴한 블럭은 인벤토리에 추가
          blockInventory++;
          blockCountElement.innerText = blockInventory;
        }
      }
    }

    // 블럭 배치: 인벤토리에 블럭이 있을 경우 화면 중앙 레이캐스트로 얻은 블럭의 면 정보를 기반으로 배치
    function placeBlock() {
      if (blockInventory <= 0) return; // 인벤토리에 배치할 블럭이 없으면 리턴
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(objects);
      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (intersect.distance < 50) {
          // 면의 법선 벡터(normal)를 이용해 블럭을 배치할 위치 계산
          const normal = intersect.face.normal.clone();
          // 배치할 위치는 충돌 지점에서 블럭 크기의 절반을 더한 위치
          const pos = intersect.point.clone().add(normal.multiplyScalar(blockSize/2));
          // 그리드에 맞게 스냅
          pos.x = Math.round(pos.x / blockSize) * blockSize;
          pos.y = Math.round(pos.y / blockSize) * blockSize + blockSize/2;
          pos.z = Math.round(pos.z / blockSize) * blockSize;
          // 이미 블럭이 있는지 확인
          let canPlace = true;
          for (let i = 0; i < objects.length; i++) {
            let o = objects[i];
            if (Math.abs(o.position.x - pos.x) < 0.1 &&
                Math.abs(o.position.y - pos.y) < 0.1 &&
                Math.abs(o.position.z - pos.z) < 0.1) {
              canPlace = false;
              break;
            }
          }
          if (canPlace) {
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.copy(pos);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
            objects.push(cube);
            blockInventory--;
            blockCountElement.innerText = blockInventory;
          }
        }
      }
    }

    // 애니메이션 및 게임 루프
    function animate() {
      requestAnimationFrame(animate);

      if (controls.isLocked === true) {
        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        // 마찰 효과
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        // 중력 적용
        velocity.y -= 9.8 * 100.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // 대각 이동 시 속도 일정화

        if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

        // 이동 적용
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += velocity.y * delta;

        // 땅과의 충돌 처리 (최소 높이 고정)
        if (controls.getObject().position.y < 10) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
          canJump = true;
        }
        prevTime = time;
      }

      renderer.render(scene, camera);
    }
    animate();

    // 창 크기 변경 대응
    window.addEventListener('resize', function(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
